
22.2 Аутентификация
9. Конспект
Этот раздел состоит из трех частей: шпаргалки, словаря и конспекта урока.
В шпаргалке вы найдете рекомендации по работе с формами, которые помогут вам при выполнении домашней работы.
В словаре и конспекте мы собрали материал со всего урока, который пригодится для дальнейшего обучения и работы.
 
Переопределить модель для работы модуля аутентификации:
# users.models
from django.contrib.auth.models import AbstractUser


class User(AbstractUser):
    pass
Настроить проект для работы с новой моделью пользователя:
# settings.py
AUTH_USER_MODEL = 'users.User'
Сгенерировать пароль:
class UserProfileView(UpdateView):
    model = User
    form_class = UserChangeForm

    def form_valid(self, form):
        if form.is_valid():
            self.object = form.save()
            if form.data.get('need_generate', False):
                self.object.set_password(
                    self.object.make_random_password(length=12)
                )
                self.object.save()

        return super().form_valid(form)
Задать основные поля для авторизации и регистрации через новую модель:
class User(AbstractUser):
    username = None
    email = models.EmailField(
        verbose_name='почта',
        unique=True
    )

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = []
Изменить формы для регистрации и авторизации:
class CustomUserCreationForm(UserCreationForm):
    pass
Поменять стандартную логику работы процесса авторизации или регистрации:
class UserLoginView(LoginView):
    pass
Кастомизировать процесс регистрации:
class UserRegisterView(CreateView):
    model = User
    form_class = CustomUserCreationForm



Модель для авторизации — специальная модель, которая наследуется от базовой модели 
AbstractUser
 из пакета
django.contrib.auth.models
.
Стандартная аутентификация — набор встроенных инструментов для осуществления входа и регистрации пользователя.
Кастомизация аутентификации — изменение функционала авторизации и регистрации пользователя путём расширения встроенных классов, а также процессов в общем виде.
Изменение поля для авторизации — определение произвольного поля для использования как идентификатора пользователя. Можно использовать почту, телефон или другое поле, которое способно уникально идентифицировать пользователя.
Формирование пароля — процесс генерации строки, которую можно использовать в качестве пароля, а также шифрование этой строки для хранения в БД.
Формы для аутентификации — набор форм из пакета Django Forms, у которых переопределено стандартное поведение для реализации базовых задач процесса аутентификации.
Переопределение поведения формы — изменение поведения родительской формы путём переопределения методов или атрибутов.
Изменение поля регистрации — определение произвольного поля для использования как идентификатора пользователя. Можно использовать почту, телефон или другое поле, которое способно уникально идентифицировать пользователя.
Контроллеры для аутентификации — контроллеры, которые реализуют функционал входа и выхода.
Переопределение поведения контроллеров — изменение поведения родительского класса путём переопределения методов или атрибутов.



Что такое аутентификация
Аутентификация — это процесс проверки подлинности личности, субъекта или объекта, чтобы установить, действительно ли он является тем, за кого себя выдает. Используется для обеспечения безопасности и контроля доступа к различным системам, устройствам или ресурсам.
Основная цель аутентификации — удостовериться в том, что сущность, пытающаяся получить доступ, действительно имеет право на этот доступ.
Для этого применяются различные методы и технологии, которые могут включать:
Что-то, что вы знаете. Это может быть пароль, ПИН-код, ответ на секретный вопрос и т. д.
Что-то, что вы имеете. Это могут быть физические предметы, такие как смарт-карты, токены, USB-ключи и даже ваш собственный смартфон, который может генерировать одноразовые коды.
Ваши биометрические характеристики. Это отпечатки пальцев, сканирование сетчатки глаза, голосовое распознавание и др.
Многокритериальные методы. Это сочетание двух или более вышеуказанных факторов для более надежной аутентификации.
Процесс аутентификации может быть реализован на разных уровнях и в разных контекстах. Например, в компьютерных системах аутентификация обычно используется для входа в учетную запись пользователя, в банковских системах — для доступа к финансовой информации, на физическом уровне — для доступа к закрытым территориям.
С развитием технологий аутентификации, таких как биометрические методы и двухфакторная аутентификация (2FA), стало возможным обеспечить более высокий уровень безопасности и защиты от несанкционированного доступа.
Аутентификация в Django
Django «из коробки» предоставляет инструменты работы с пользователями и их действиями в сервисе. Эти инструменты со временем развивались и улучшались, но всё же имеют недостатки и устаревшие функциональности. Так как весь фреймворк написан, опираясь на лучшие практики работы с кодом и архитектурами, данные инструменты можно расширять и дополнять без каких-либо проблем.
В инструменты аутентификации в Django входят:
User-модель. Django предоставляет встроенную модель
User
 (пользователь), которая содержит основные поля, такие как имя пользователя, адрес электронной почты и пароль. Вы можете использовать эту модель для хранения информации о пользователях вашего приложения.
Формы аутентификации. Django предоставляет формы для процессов аутентификации, такие как вход (логин) и регистрация. Они облегчают создание пользовательских интерфейсов для ввода данных.
Механизм сессий. Django автоматически управляет сессиями пользователей. Это позволяет хранить информацию о входе пользователя через несколько запросов, обеспечивая сохранение его аутентификационного состояния.
Декораторы аутентификации. Django предоставляет декораторы (аннотации в Python) для ограничения доступа к определенным представлениям (вьюхам) только для аутентифицированных пользователей. Например,
@login_required
 и 
LoginRequiredMixin
 — декоратор и миксин, требующие входа пользователя для доступа к определенной странице.
Бэкенды аутентификации. Django поддерживает различные методы аутентификации, такие как базовая аутентификация, аутентификация через социальные сети, аутентификация с использованием электронной почты и т. д. Вы можете настраивать и выбирать подходящий бэкенд в зависимости от ваших потребностей.
Группы и права доступа. Django предоставляет систему групп пользователей и управления правами доступа. Это позволяет организовать пользователей в группы и предоставлять различные уровни доступа к разным частям вашего приложения.
Панель администратора. Django имеет встроенную административную панель, которая позволяет администраторам управлять пользователями, их учетными записями и правами доступа.
Django предоставляет полный стек инструментов для создания безопасных систем аутентификации и управления пользователями в вашем веб-приложении.
Процесс аутентификации подразумевает под собой процесс проверки подлинности пользователя путем сравнения введенного им логина и пароля с сохраненными в базе данных. Аутентификация включает также процесс внесения данных пользователя в базу данных и возможное подтверждение этих данных путем верификации.
Верификация в данном случае означает процесс подтверждения пользователем введенных действий. Например, отправка на почту ссылки на подтверждение этой почты или отправка кода в SMS по указанному телефону.
Работа с переопределением модели
Для работы с описанием кастомной модели предусмотрен специальный класс AbstractUser, наследуясь от которого можно получить весь необходимый функционал работы пользователя, который предоставляет модуль аутентификации. В фреймворке модуль аутентификации имеет название 
auth
.
При кастомизации модели важно соблюдать последовательность действий:
Переопределение модели — важный шаг, с которого начинается работа по кастомизации. Благодаря переопределению модели можно изменить модель пользователя, расширить ее или модифицировать.
Пример переопределения модели для работы модуля аутентификации:
# django/contrib/auth/models.py
class AbstractUser(AbstractBaseUser, PermissionsMixin):
    """ Модель, от которой необходимо наследоваться """
    username_validator = UnicodeUsernameValidator()

    username = models.CharField(
        _("username"),
        max_length=150,
        unique=True,
        help_text=_(
            "Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only."
        ),
        validators=[username_validator],
        error_messages={
            "unique": _("A user with that username already exists."),
        },
    )
    first_name = models.CharField(_("first name"), max_length=150, blank=True)
    last_name = models.CharField(_("last name"), max_length=150, blank=True)
    email = models.EmailField(_("email address"), blank=True)
    is_staff = models.BooleanField(
        _("staff status"),
        default=False,
        help_text=_("Designates whether the user can log into this admin site."),
    )
    is_active = models.BooleanField(
        _("active"),
        default=True,
        help_text=_(
            "Designates whether this user should be treated as active. "
            "Unselect this instead of deleting accounts."
        ),
    )
    date_joined = models.DateTimeField(_("date joined"), default=timezone.now)

# users/models.py
from django.contrib.auth.models import AbstractUser


class User(AbstractUser):
    pass
В примере и в исходных кода фреймворка можно обнаружить следующий вызов: 
_('some text')
. Функция 
_
 — это использование инструмента интернационализации, который автоматически переводит текст на выбранный язык системы.
Настройка проекта — шаг, благодаря которому мы сообщаем проекту, что теперь для авторизации используется новая модель. Для этого нужно внести в файл
settings.py
 важную настройку
AUTH_USER_MODEL = 'users.User'
:
# settings.py
AUTH_USER_MODEL = 'users.User'
Помимо перечисленных шагов, есть опциональные шаги, которые увеличивают контроль над процессом аутентификации пользователя, но в то же время не являются обязательными:
Генерация пароля позволяет задавать правила формирования пароля и использовать функциональности автогенерации для пользователей, которые пожелали того:
class UserProfileView(UpdateView):
    model = User
    form_class = UserChangeForm

    def form_valid(self, form):
        # Метод, который отрабатывает при успешной валидации формы
        if form.is_valid():
            self.object = form.save()
            # Сохранение объекта перед тем, как установить ему пароль
            if form.data.get('need_generate', False):
                self.object.set_password( # Функция установки пароля, 
                # которая хеширует строку для того, 
                # чтобы не хранить пароль в открытом виде в БД
                    self.object.make_random_password(12) # Функция генерации пароля
                )
                self.object.save()

        return super().form_valid(form)
Изменение полей авторизации  позволяет привязаться при авторизации к полям, которые есть у модели пользователя или которые были добавлены в процессе переопределения, например поле почты или телефона:
from django.contrib.auth.models import AbstractUser
from django.db import models


class User(AbstractUser):
    username = None

    email = models.EmailField(verbose_name='почта', unique=True)

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = []
Обратите внимание, что в таком виде реализации у проекта потеряет актуальность работа команды
createsuperuser
.
Чтобы создавать суперпользователя:
Можно написать свою кастомную команду.
Например:
# users/management/commands/csu.py
from django.core.management import BaseCommand

from users.models import User


class Command(BaseCommand):

    def handle(self, *args, **options):
        user = User.objects.create(
            email='admin@sky.pro',
            first_name='Admin',
            last_name='SkyPro',
            is_staff=True,
            is_superuser=True
        )

        user.set_password('123qwe456rty')
        user.save()
Либо описать менеджер объектов для модели пользователя, тогда команда восстановит свою работоспособность. Пример:
# users/models.py
class UserManager(UserBaseManager):
    use_in_migrations = True

    def _create_user(self, email, password, **extra_fields):
        if not email:
            raise ValueError("The given username must be set")
        email = self.normalize_email(email)
        GlobalUserModel = apps.get_model(
            self.model._meta.app_label, self.model._meta.object_name
        )
        email = GlobalUserModel.normalize_username(email)
        user = self.model(email=email, **extra_fields)
        user.password = make_password(password)
        user.save(using=self._db)
        return user

    def create_user(self, email, password=None, **extra_fields):
        extra_fields.setdefault("is_staff", False)
        extra_fields.setdefault("is_superuser", False)
        return self._create_user(email, password, **extra_fields)

    def create_superuser(self, email, password=None, **extra_fields):
        extra_fields.setdefault("is_staff", True)
        extra_fields.setdefault("is_superuser", True)

        if extra_fields.get("is_staff") is not True:
            raise ValueError("Superuser must have is_staff=True.")
        if extra_fields.get("is_superuser") is not True:
            raise ValueError("Superuser must have is_superuser=True.")

        return self._create_user(email, password, **extra_fields)


class User(AbstractUser):
    ...

    objects = UserManager()
Подведем небольшой итог.
При переопределении модели помните:
Наследоваться нужно от AbstractUser.
У данного класса уже есть свои поля, поэтому нужно обращать на них внимание при необходимости как-то расширить модель.
Любое исходное поле можно переопределить или исключить из модели.
В наследовании нужно стараться не уходить дальше AbstractUser.
Путь наследования начинается со стандартного класса для описания моделей и выглядит следующим образом:

Формы
У модуля аутентификации есть набор встроенных форм, которые наследуются от обычных форм, но предоставляют дополнительный функционал. Этот функционал можно переопределять, расширять или изменить полностью, чтобы переделать логику поведения формы под необходимую.
Важно помнить:
Все формы наследуются от стандартных форм, поэтому изменять поведения для них можно точно так же, как при работе со стандартными формами.
Поведение форм лучше переопределять, опираясь на поведение исходной формы, в которой необходимо изменить функционал.
Имеющиеся в Django формы аутентификации:
UserCreationForm
 — создание или регистрация пользователя.
UserChangeForm
 — редактирование данных пользователя.
AuthenticationForm
 — авторизация пользователя.
PasswordChangeForm
 — изменение пароля пользователем.
PasswordResetForm
 — сброс пароля пользователем.
SetPasswordForm
 — установка пароля пользователем.
Пример 
AuthenticationForm
:
class CustomAuthenticationForm(AuthenticationForm):

    class Meta:
        model = User
        fields = ('email', 'password', 'some_data')
Контроллеры
У встроенного модуля аутентификации есть набор контроллеров, которые можно использовать, например, для авторизации или работы с паролем.
Во всех остальных случаях (регистрация или редактирование профиля) используются Generic-классы. Чтобы поведение программы отвечало требованиям, необходимо Generic-классам указывать формы из предыдущего раздела. Для регистрации или создания пользователя необходимо использовать класс 
CreateView
, а для редактирования профиля можно использовать 
UpdateView
.
Пример:
# urls.py
# Добавляем в урлы приложения обработку запроса на регистрацию
path('register/', RegisterView.as_view(), name='register'),

# forms.py
class RegisterForm(UserCreationForm):
    # Наследуемся от специальной формы UserCreationForm из модуля auth
    class Meta:
        model = User
        # Указываем новую кастомную модель
        fields = ('email', 'password1', 'password2',)
        # Меняем поля, так как исходная форма UserCreationForm 
        # ссылается на поле username

# views.py
class RegisterView(CreateView):
    # Создаем обычный контроллер на создание сущности
    model = User
    form_class = RegisterForm
На практике используются не все встроенные контроллеры.
Чаще всего применяются:
LoginView
 — контроллер авторизации.
LogoutView
 — контроллер выхода.
Однако важно знать, что есть набор контроллеров, которые не используются часто, но имеются в стандартном наборе контроллеров и могут быть полезны при выполнении нетривиальных задач:
PasswordResetView
 — контроллер для запуска процесса сброса пароля.
PasswordChangeView
 — контроллер для смены пароля, то есть ввода данных.
PasswordChangeDoneView
 — контроллер для отображения страницы успешного заполнения данных.
PasswordResetConfirmView
 — контроллер для подтверждения сброса пароля.
PasswordResetCompleteView
 — контроллер для отображения страницы успешного сброса пароля.
PasswordResetDoneView
 — контроллер для отображения страницы завершения процесса сброса пароля.
При выполнении задач важно помнить:
Некоторые формы уже реализованы, но их можно смело переопределять и добиваться необходимого поведения.
В имеющемся наборе контроллеров есть только авторизация и выход для текущей задачи, остальные необходимо реализовать самостоятельно на основе Generic-классов.
2 вопроса

Эдуард Кусков
(изменено)
Код для описания менеджера объектов для модели пользователя дает ошибку "TypeError: UserManager.create_superuser() missing 1 required positional argument: 'username' ". Думаю как исправить.  https://github.com/TheShadowfish/pythonProject2/tree/createsuperuser_need_to_be_fixed



О
9 комментариев
16.06.24 22:08
М
Мария Свинцова
Добрый день! У меня не получается запустить страничку по адресу http://127.0.0.1:8000/register/
Не получается исправить ошибки с миграциями, возможно изза этого. Подскажите, пожалуйста, что не так?https://github.com/MariaSvintsova/Django.git

М


13 комментариев
13.05.24 13:25



 